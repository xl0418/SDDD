{
    "collab_server" : "",
    "contents" : "library(DDD)\n\n#Please put Nindex.R and event_matrix.R scripts under the main directory (getwd() can show the main directory)\nsource(paste0(getwd(),'/Nindex.R'))\nsource(paste0(getwd(),'/event_matrix.R'))\n# Arguments introduction\n# n: number of locations in the model. Multiple locations model is already incorporated. \n# parsN: a vector of number of species on each location at initial stage. In total, the number of species \n#        in the system should be 2.\n# For example: if set n = 2, parsN can be set as parsN = c(1,1) which means 1 species for each location\n#              parsN = c(2,0) which means 2 species on location 1 and 0 species on location 2.\n#              In this case, we can set migration rate to 0 to approach our spatial model to non-spatial model.\n# age: crown age. As the simulation is conditioning on the survival of two ancestor specis, the crown age is fixed.\n# pars: a vector of parameters. (lambda, mu, K'( or K)).\n#              lambda: intrisic speciation rate\n#              mu: extinction rate\n#              K': ecological limit when argument K_fix = 0\n#              K : carrying capacity when argument K_fix = 1\n# seed_fun: seed for the simulation.\n# lambda_allo0: intrisic allopatric speciation rate.\n# M0: intrisic migration rate. \n# K_fix: fix carrying capacity (K_fix = 1) or fix ecological limit (K_fix = 0)\n\nsddsim<-function(n,parsN,age=20,pars , seed_fun = 29, lambda_allo0 = 0.2, M0=1,K_fix = 1){\n  set.seed(seed_fun)\n  if (length(parsN) == n){\n    if(sum(parsN) ==2 | sum(parsN)==1){\n      done = 0\n      while(done == 0)\n      {         \n        event_info_track = NULL\n        brts = c(0,\"start\")\n        lambda0 = pars[1]\n        mu0 = pars[2]\n        \n        #fix K, the carrying capacity\n        if(K_fix == 1) {  K = pars[3]   # K is carrying capacity\n        K= lambda0*K/(lambda0 - mu0) # here it is K'\n        }\n        #fix K', the limit to the diversity\n        if(K_fix == 0){K = pars[3]}\n        \n        if(length(pars) == 3){\n          K_loc = rep(K,n)   # carrying capacity for each location\n        }\n        if(length(pars) > 3){\n          K_loc = pars[-(1:2)]   # carrying capacity for each location\n        }\n        \n        probs_record = NULL\n        t <- 0\n        # Na : number of species in location A\n        # Nb : number of species in location B\n        # Nab: number of species in location AB\n        # age : time\n        # Ki : carrying capacity of location i\n        # lambda0 : initial speciation rate\n        # mu0 : initial extinction rate  \n        \n        mu = rep(mu0,n)\n        # string of events\n        #track locations as the maps of the \"phylo\" class\n        track_loc = list()\n        for(i in 1:n){\n          track_loc[[i]]=0\n          names(track_loc[[i]])=c(paste(i))\n        }\n        N=sum(parsN)\n        Ntable_index = Nindex(n)\n        Nlength = sum(Ntable_index)\n        Ntable = matrix(0,nrow =1, ncol =Nlength)\n        Ntable[1:n] = parsN\n        i=0\n        # L : Ltable used in L2phylo function of DDD package \n        # L = data structure for lineages,\n        # . L[,1] = branching times\n        # . L[,2] = index of parent species\n        # . L[,3] = index of daughter species\n        # . L[,4] = time of extinction\n        # . L[,5] = index of location\n        # j = index running through L\n        \n        loctable= NULL\n        \n        L = NULL\n        for(j in 1:N){\n          loc = which(Ntable[1,]!=0)\n          L = rbind(L, c(0, 1-j, (-1)^j*j, -1, loc[1]))\n          L = matrix(L, ncol = 5)\n          loc1= matrix(0,1,n)\n          loc1[1,loc[1]] = 1 \n          loctable = rbind(loctable, loc1)\n          linlist = cbind(L[,3], L[,5])\n          Ntable[1,loc[1]] = Ntable[1,loc[1]] -1 \n          newL=j\n        }\n        \n        Ntable = matrix(0,nrow =1, ncol =Nlength)\n        Ntable[1:n] = parsN\n        \n        spec_num = sum(Nindex(n)[1,])\n        N_loc = matrix(0,nrow = n,ncol = spec_num)\n        N_loc_col = matrix(0,nrow = n,ncol = spec_num)\n        Ndistribution = event_matrix(n)\n        \n        #index for sym speciation\n        for(j in 1:n){\n          N_loc_col[j,] = which(Ndistribution[j,] == 1,arr.ind = TRUE)#index of each loc in sym spec table\n        }\n        B_symspec = c(N_loc_col)\n        \n        #index for extinction\n        B_ext = NULL\n        x = Ndistribution\n        y = split(x, rep(1:ncol(x), each = nrow(x)))\n        for(j in 1:n){\n          x1 = x\n          x1[j,] = x1[j,]-1\n          y1 = split(x1, rep(1:ncol(x1), each = nrow(x1)))\n          z = match(y1,y)\n          z = z[!is.na(z)]\n          B_ext = rbind(B_ext, z)\n        }\n        B_ext = c(rep(0,n), B_ext)\n        \n        #index for allo speciation\n        lambda_allo = NULL\n        allo_dau1 = NULL\n        allo_dau2 = NULL\n        allo_par = NULL\n        N_allo = colSums(Ndistribution)\n        for(j in 1:(n-1)){\n          allo_index = which(N_allo > 1 )\n          allo_matrix = Ndistribution[,allo_index,drop = FALSE]\n          allo_matrix_daughter = matrix(0,nrow = nrow(allo_matrix),ncol = ncol(allo_matrix))\n          allo_matrix_daughter1 = allo_matrix_daughter\n          allo_matrix_daughter1[1:j,] = allo_matrix[1:j,]\n          allo_matrix_daughter2 = allo_matrix\n          allo_matrix_daughter2[1:j,] = 0\n          allo_col_cut1 = which(colSums(allo_matrix_daughter1) == 0)\n          allo_col_cut2 = which(colSums(allo_matrix_daughter2) == 0)\n          allo_col_cut = c(allo_col_cut1,allo_col_cut2)\n          \n          if(length(allo_col_cut) != 0) {\n            allo_matrix_daughter1_rest = allo_matrix_daughter1[,-allo_col_cut]\n            allo_matrix_daughter2_rest = allo_matrix_daughter2[,-allo_col_cut]\n            allo_index_final = allo_index[-allo_col_cut]\n          }\n          else {\n            allo_matrix_daughter1_rest = allo_matrix_daughter1\n            allo_matrix_daughter2_rest = allo_matrix_daughter2\n            allo_index_final = allo_index\n            \n          }\n          allo_dau1 = cbind(allo_dau1,allo_matrix_daughter1_rest)\n          allo_dau2 = cbind(allo_dau2,allo_matrix_daughter2_rest)\n          allo_par = c(allo_par, allo_index_final)\n        }\n        B_allodau1 = match(data.frame(allo_dau1),data.frame(Ndistribution))\n        B_allodau2 = match(data.frame(allo_dau2),data.frame(Ndistribution))\n        allo_index = allo_par\n        \n        \n        # ignore the linear topology of locations\n        matrix_allo = rbind(B_allodau1,B_allodau2,allo_index)\n        duplicated.columns <- duplicated(t(matrix_allo))\n        new.matrix <- matrix_allo[, !duplicated.columns,drop = FALSE]\n        B_allodau1 = new.matrix[1,]\n        B_allodau2 = new.matrix[2,]\n        allo_index = new.matrix[3,]\n        \n        \n        #index for migration\n        B_mig_target = which(Ndistribution == 0, arr.ind = TRUE)\n        B_mig_from = c(B_mig_target[,2])\n        B_mig_to = c(B_mig_target[,1])\n        \n        B_mig_bec = NULL\n        for(j in 1:length(B_mig_from)){\n          Ndis_aftermig = Ndistribution\n          Ndis_aftermig[B_mig_to[j],B_mig_from[j]] = 1\n          loc_aftermig = as.vector(Ndis_aftermig[,B_mig_from[j]])\n          B_mig_bec = c(B_mig_bec,which(sapply( y ,function(x)all(x==loc_aftermig))))\n        }\n        B_mig_bec = as.numeric(B_mig_bec)\n        \n        #number of events\n        #sym spec\n        num_ss = 0\n        for(i in 1:(n-1))\n        {\n          num_ss = num_ss+choose(n-1,i)\n        }\n        num_ss = n*(1+num_ss)\n        \n        #ext \n        num_ext = num_ss\n        \n        #allo spec\n        num_as = length(allo_index)\n        \n        #mig \n        num_mig = 0\n        for(i in 1:(n-1)){\n          num_mig = num_mig + choose(n,i)*(n-i)\n        }\n        \n        #number of events\n        num_event = num_ss + num_ext + num_as + num_mig\n        probs_part1 = num_ss \n        probs_part2 = num_ext\n        probs_part3 = num_as\n        probs_part4 = num_mig\n        \n        \n        B<- c(1:num_event)\n        \n        i = 0\n        log_likelihood = 0\n        while(t[i+1]< age){\n          i<-i+1\n          \n          # speciation event & extinction event\n          lambda_sym = rep(0,n)\n          mu = rep(mu0,n)\n          \n          sym_spec_event = matrix(0,nrow = n,ncol = spec_num)\n          ext_event = matrix(0,nrow = n,ncol = spec_num)\n          \n          for(j in 1:n){\n            N_loc[j,] = Ntable[i,which(Ndistribution[j,]==1)]  #number of each loc in sym spec table\n            lambda_sym[j]=max(lambda0*(1-sum(N_loc[j,])/K_loc[j]),0)\n            sym_spec_event[j,] = lambda_sym[j]*N_loc[j,] \n            ext_event[j,] = mu[j] *N_loc[j,]\n          }\n          prob_spec_sym = c(sym_spec_event)\n          prob_ext = c(ext_event)\n          \n          \n          # Migration \n          prob_mig = NULL\n          Mig_dir = rep(0,n)\n          for(j in 1:n){\n            Mig_dir[j] = max(M0*(1-sum(N_loc[j,])/K_loc[j]),0)\n          }\n          for(j in 1:(ncol(Ntable)-1)){\n            tar = which(Ndistribution[,j]==0)\n            prob_mig_each = Ntable[i,j]*Mig_dir[tar]\n            prob_mig_each = matrix(prob_mig_each,ncol = length(prob_mig_each))\n            prob_mig = cbind(prob_mig,prob_mig_each)\n          }\n          prob_mig = c(prob_mig)\n          \n          \n          # Allopatric speciation event\n          lambda_allo = NULL\n          for(j in allo_index){\n            Mig_base =  M0  \n            if(Mig_base == 0) lambda_allo_each = 1*Ntable[i,j]\n            else lambda_allo_each = max(lambda_allo0/Mig_base, 0 )*Ntable[i,j]\n            lambda_allo = cbind(lambda_allo,lambda_allo_each)\n          }\n          prob_spec_allo = c(lambda_allo)\n          \n          #probs of all events\n          probs= c(prob_spec_sym,prob_ext,prob_spec_allo,prob_mig)\n          probs_record = rbind(probs_record,probs)\n          #Total rate\n          TR =sum(probs)\n          \n          if(TR ==0) break\n          else{\n            A<-DDD::sample2(B,1, prob = probs)\n            t_wait = rexp(1,rate=TR)\n            t[i+1]=t[i]+t_wait\n            \n            prob_waiting_time = 1-exp(-TR*t_wait)\n            \n            if(t[i+1]>age) break\n            loc2 = matrix(0,1,n)\n            log_likelihood = log_likelihood + log(prob_waiting_time) + log(probs[A]/TR)\n            \n            # Sympatric speciation \n            if (is.element(A,1:probs_part1)){\n              \n              b1<-A%%n\n              if(b1 == 0) b1 = n\n              Ntable=rbind(Ntable,Ntable[i,])\n              Ntable[i+1,b1] = Ntable[i,b1]+1\n              newL = newL + 1;\n              list0 = matrix(linlist,ncol = 2)\n              b3 <- B_symspec[A]\n              \n              list1 = linlist[list0[,2]== b3]\n              \n              list2 = matrix(list1, ncol = 2)\n              \n              linlist1 = list2[,1]\n              \n              ranL= DDD::sample2(linlist1,1)\n              L = rbind(L,c(t[i+1],ranL,sign(ranL) * newL,-1,b1))\n              linlist = rbind(linlist,c(sign(ranL) * newL,b1)) \n              loc2[1,b1] = 1\n              loctable = rbind(loctable, loc2)\n              #change of loc info\n              track_loc[[abs(ranL)]]=c(track_loc[[abs(ranL)]],t[i+1])\n              names(track_loc[[abs(ranL)]])[length(names(track_loc[[abs(ranL)]]))]=c(paste(b3))\n              track_loc[[newL]]=track_loc[[abs(ranL)]]\n              names(track_loc[[newL]])[length(names(track_loc[[newL]]))]=c(paste(b1))\n              \n              event_info_track = c(event_info_track, c(paste0(\"t\",abs(ranL),\" gave birth to \",newL)))\n              brts = rbind(brts, c(t[i+1],paste0(\"t\",abs(ranL),\" gave birth to \",\"t\",newL)))\n            }\n            \n            #Extinction\n            else if(is.element(A,(probs_part1+1):(probs_part1+probs_part2))) {\n              \n              \n              b1<-A%%n\n              if(b1 == 0) b1 = n\n              Ntable=rbind(Ntable,Ntable[i,])\n              b3 <- B_symspec[A-probs_part1]\n              list0 = matrix(linlist,ncol = 2)\n              list1 = linlist[list0[,2]== b3]\n              list2 = matrix(list1, ncol = 2)\n              linlist1 = list2[,1]\n              ranL= DDD::sample2(linlist1,1)\n              loctable[abs(ranL),b1] = 0\n              # Go extinct\n              if(is.element(A,(probs_part1+1):(probs_part1+n))){\n                \n                \n                Ntable[i+1,b3] = max(Ntable[i,b3]-1,0)\n                L[abs(ranL),4] = t[i+1]\n                if(length(L[L[,4]== -1]) == 0) break\n                else {\n                  v = which(linlist[,1] == ranL)\n                  linlist = linlist[-v,,drop=FALSE]\n                  linlist = linlist[order(linlist[,1]),]\n                  linlist = matrix(linlist,ncol=2)\n                  \n                  track_loc[[abs(ranL)]]=c(track_loc[[abs(ranL)]],t[i+1])\n                  names(track_loc[[abs(ranL)]])[length(names(track_loc[[abs(ranL)]]))]=c(\"0\")\n                  event_info_track = c(event_info_track, c(paste0(\"t\",abs(ranL),\" went extinct\")))\n                  \n                }\n              }\n              # Contraction\n              else{\n                \n                b2 <- B_ext[A-probs_part1]\n                Ntable[i+1,b3] = Ntable[i,b3]-1\n                Ntable[i+1,b2] = Ntable[i,b2]+1\n                L[abs(ranL),5] <- b2\n                v = which(linlist[,1] == ranL)\n                linlist[v,2] = b2\n                linlist = linlist[order(linlist[,1]),]\n                linlist = matrix(linlist,ncol=2)\n                \n                \n                track_loc[[abs(ranL)]]=c(track_loc[[abs(ranL)]],t[i+1])\n                names(track_loc[[abs(ranL)]])[length(names(track_loc[[abs(ranL)]]))]=c(paste(b2))\n                \n                event_info_track = c(event_info_track, c(paste0(\"t\",abs(ranL),\" contracted to \",b2)))\n                \n              }\n              \n            }\n            \n            \n            # Allopatric speciation \n            else if(is.element(A,((probs_part1+probs_part2)+1):(probs_part1+probs_part2+probs_part3))) {\n              \n              A1 = A - (probs_part1+probs_part2)\n              \n              Ntable=rbind(Ntable,Ntable[i,])\n              Ntable[i+1,B_allodau1[A1]] = Ntable[i,B_allodau1[A1]]+1\n              Ntable[i+1,B_allodau2[A1]] = Ntable[i,B_allodau2[A1]]+1\n              Ntable[i+1,allo_index[A1]] = Ntable[i,allo_index[A1]]-1\n              newL = newL + 1\n              list0 = matrix(linlist,ncol = 2)\n              list1 = linlist[list0[,2]==allo_index[A1]]\n              list2 = matrix(list1, ncol = 2)\n              linlist1 = list2[,1]\n              ranL= DDD::sample2(linlist1,1)\n              L[abs(ranL),5] <- B_allodau1[A1]\n              loctable[abs(ranL), ] = Ndistribution[,B_allodau1[A1]]\n              v = which(linlist[,1] == ranL)\n              linlist[v,2] = B_allodau1[A1]\n              L = rbind(L,c(t[i+1],ranL,sign(ranL) * newL,-1,B_allodau2[A1]))\n              linlist = rbind(linlist,c(sign(ranL) * newL,B_allodau2[A1]))  \n              loc2[1,] = Ndistribution[,B_allodau2[A1]] \n              loctable = rbind(loctable,loc2)\n              #change of loc info\n              track_loc[[abs(ranL)]]=c(track_loc[[abs(ranL)]],t[i+1])\n              names(track_loc[[abs(ranL)]])[length(names(track_loc[[abs(ranL)]]))]=c(paste(B_allodau1[A1]))\n              track_loc[[newL]]=track_loc[[abs(ranL)]]\n              names(track_loc[[newL]])[length(names(track_loc[[newL]]))]=c(paste(B_allodau2[A1]))\n              event_info_track = c(event_info_track, c(paste(\"t\",abs(ranL),\" gave birth to \",B_allodau1[A1],\" & \",B_allodau2[A1])))\n              brts = rbind(brts, c(t[i+1],paste0(\"t\",abs(ranL),\" gave birth to \",B_allodau1[A1],\" & \",B_allodau2[A1])))\n              \n            }\n            \n            #Migration\n            else {\n              \n              \n              Mig1 = B_mig_from \n              Mig2 =  B_mig_bec  \n              Mig3 = B_mig_to \n              Am = A - (probs_part1+probs_part2+probs_part3)\n              b2 = Mig1[Am]\n              b3 = Mig2[Am]\n              Ntable=rbind(Ntable,Ntable[i,])\n              Ntable[i+1,b2]=Ntable[i,b2]-1\n              Ntable[i+1,b3]=Ntable[i,b3]+1\n              linlist = matrix(linlist,ncol = 2)\n              list1 = linlist[linlist[,2]==b2]\n              list2 = matrix(list1, ncol = 2)\n              linlist1 = list2[,1]\n              ranL1 = DDD::sample2(linlist1,1)\n              L[abs(ranL1),5] <- b3\n              v = which(linlist[,1] == ranL1)\n              linlist[v,2] = b3\n              linlist = linlist[order(linlist[,1]),]\n              linlist = matrix(linlist,ncol=2)\n              loctable[abs(ranL1),Mig3[Am]] = 1\n              #change of loc info\n              track_loc[[abs(ranL1)]]=c(track_loc[[abs(ranL1)]],t[i+1])\n              names(track_loc[[abs(ranL1)]])[length(names(track_loc[[abs(ranL1)]]))]=c(paste(b3))\n              event_info_track = c(event_info_track, c(paste(abs(ranL1),\" dispersed and becomes\",b3)))\n              \n            }\n            \n            if(sum(linlist[,1] < 0) == 0 | sum(linlist[,1] > 0) == 0) \n            { \n              break\n            }\n            \n            N[i+1]=sum(Ntable[i+1,])\n            \n          }\n        }\n        \n        if(sum(linlist[,1] < 0) == 0 | sum(linlist[,1] > 0) == 0)\n        {\n          done = 0\n          \n        } else {\n          done = 1\n        }\n      }  \n    \n      if(dim(L)[1]==1)\n        print(paste(\"It goes extinct at the begining!\"))\n      else{\n        L[,1]=age-L[,1]\n        notmin1 = which(L[,4] != -1)\n        L[notmin1,4] = age - c(L[notmin1,4])\n        L[which(L[,4] == age + 1),4] = -1\n        \n        tes = L2phylo(L,dropextinct = T)\n        tas = L2phylo(L,dropextinct = F)\n        out = list(tes = tes,tas = tas,L = L, loctable = loctable, Ntable = Ntable,t = t,log_likelihood = log_likelihood,probs_record = probs_record,track_loc = track_loc,event_info_track=event_info_track,brts = brts)\n\n        return(out)\n      }\n    }\n    else print(paste(\"please input 1 or 2 species in total!\"))\n  }\n  else print(paste(\"please match the length of parsN to n\"))\n  \n}\nprint(paste(\"Please input initial number of lineages of each loc with no more than 2 species in total! Match number n and dimentions of parsN \"))\n\n",
    "created" : 1507905419850.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1602471529",
    "id" : "2C53618F",
    "lastKnownWriteTime" : 1507905214,
    "last_content_update" : 1507905214,
    "path" : "~/Googlebox/Research/Project1/R_pro1/Final/SDDD/R/sddsim.R",
    "project_path" : "R/sddsim.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}